const fs = require('fs').promises;\nconst path = require('path');\nconst { v4: uuidv4 } = require('uuid');\n\nclass SessionManager {\n  constructor() {\n    this.sessionsFile = path.join(__dirname, '../../data/sessions.json');\n    this.ensureDataDirectory();\n  }\n\n  async ensureDataDirectory() {\n    const dataDir = path.dirname(this.sessionsFile);\n    try {\n      await fs.access(dataDir);\n    } catch {\n      await fs.mkdir(dataDir, { recursive: true });\n    }\n  }\n\n  async loadSessions() {\n    try {\n      const data = await fs.readFile(this.sessionsFile, 'utf8');\n      return JSON.parse(data || '[]');\n    } catch {\n      return [];\n    }\n  }\n\n  async saveSessions(sessions) {\n    await this.ensureDataDirectory();\n    await fs.writeFile(this.sessionsFile, JSON.stringify(sessions, null, 2), 'utf8');\n  }\n\n  async createSession(candidateData, questions) {\n    const session = {\n      id: uuidv4(),\n      candidateId: candidateData.candidateId || uuidv4(),\n      candidate: candidateData,\n      questions: questions.map((q, index) => ({\n        id: q.id || `q-${index}`,\n        text: q.question || q.text,\n        type: q.type || 'general',\n        difficulty: q.difficulty || 'medium',\n        timeLimit: this.getTimeLimit(q.difficulty || 'medium'),\n        category: q.category || 'technical'\n      })),\n      answers: {},\n      currentQuestionIndex: 0,\n      status: 'active', // active, paused, completed, abandoned\n      startedAt: Date.now(),\n      lastActivityAt: Date.now(),\n      completedAt: null,\n      aiEvaluation: null,\n      metadata: {\n        userAgent: '',\n        ipAddress: '',\n        deviceInfo: ''\n      }\n    };\n\n    const sessions = await this.loadSessions();\n    sessions.push(session);\n    await this.saveSessions(sessions);\n    \n    return session;\n  }\n\n  getTimeLimit(difficulty) {\n    const timeLimits = {\n      'easy': 30,\n      'medium': 60,\n      'hard': 120\n    };\n    return timeLimits[difficulty] || 60;\n  }\n\n  async getSession(sessionId) {\n    const sessions = await this.loadSessions();\n    return sessions.find(s => s.id === sessionId);\n  }\n\n  async updateSession(sessionId, updates) {\n    const sessions = await this.loadSessions();\n    const sessionIndex = sessions.findIndex(s => s.id === sessionId);\n    \n    if (sessionIndex === -1) {\n      throw new Error('Session not found');\n    }\n\n    sessions[sessionIndex] = {\n      ...sessions[sessionIndex],\n      ...updates,\n      lastActivityAt: Date.now()\n    };\n\n    await this.saveSessions(sessions);\n    return sessions[sessionIndex];\n  }\n\n  async saveAnswer(sessionId, questionIndex, answer) {\n    const session = await this.getSession(sessionId);\n    if (!session) {\n      throw new Error('Session not found');\n    }\n\n    const answerData = {\n      text: answer.text || '',\n      submittedAt: Date.now(),\n      timeSpent: answer.timeSpent || 0,\n      isAutoSubmitted: answer.isAutoSubmitted || false,\n      confidence: answer.confidence || null,\n      voiceMetrics: answer.voiceMetrics || null\n    };\n\n    const updates = {\n      answers: {\n        ...session.answers,\n        [questionIndex]: answerData\n      },\n      currentQuestionIndex: questionIndex + 1\n    };\n\n    // Check if interview is complete\n    if (questionIndex + 1 >= session.questions.length) {\n      updates.status = 'completed';\n      updates.completedAt = Date.now();\n    }\n\n    return await this.updateSession(sessionId, updates);\n  }\n\n  async pauseSession(sessionId) {\n    return await this.updateSession(sessionId, { status: 'paused' });\n  }\n\n  async resumeSession(sessionId) {\n    return await this.updateSession(sessionId, { status: 'active' });\n  }\n\n  async abandonSession(sessionId) {\n    return await this.updateSession(sessionId, { \n      status: 'abandoned',\n      abandonedAt: Date.now()\n    });\n  }\n\n  async completeSession(sessionId, aiEvaluation) {\n    return await this.updateSession(sessionId, {\n      status: 'completed',\n      completedAt: Date.now(),\n      aiEvaluation\n    });\n  }\n\n  async getAllSessions(candidateId = null) {\n    const sessions = await this.loadSessions();\n    \n    if (candidateId) {\n      return sessions.filter(s => s.candidateId === candidateId);\n    }\n    \n    return sessions.sort((a, b) => (b.lastActivityAt || 0) - (a.lastActivityAt || 0));\n  }\n\n  async getSessionStats(sessionId) {\n    const session = await this.getSession(sessionId);\n    if (!session) return null;\n\n    const totalQuestions = session.questions.length;\n    const answeredQuestions = Object.keys(session.answers).length;\n    const completionRate = (answeredQuestions / totalQuestions) * 100;\n    \n    let totalTimeSpent = 0;\n    let averageTimePerQuestion = 0;\n    \n    Object.values(session.answers).forEach(answer => {\n      totalTimeSpent += answer.timeSpent || 0;\n    });\n    \n    if (answeredQuestions > 0) {\n      averageTimePerQuestion = totalTimeSpent / answeredQuestions;\n    }\n\n    return {\n      sessionId: session.id,\n      candidateName: session.candidate?.personalInfo?.name || 'Unknown',\n      status: session.status,\n      totalQuestions,\n      answeredQuestions,\n      completionRate: Math.round(completionRate),\n      totalTimeSpent,\n      averageTimePerQuestion: Math.round(averageTimePerQuestion),\n      startedAt: session.startedAt,\n      completedAt: session.completedAt,\n      overallScore: session.aiEvaluation?.overall?.score || null\n    };\n  }\n\n  async deleteSession(sessionId) {\n    const sessions = await this.loadSessions();\n    const filteredSessions = sessions.filter(s => s.id !== sessionId);\n    await this.saveSessions(filteredSessions);\n    return filteredSessions.length < sessions.length;\n  }\n\n  async cleanupOldSessions(daysOld = 30) {\n    const sessions = await this.loadSessions();\n    const cutoffTime = Date.now() - (daysOld * 24 * 60 * 60 * 1000);\n    \n    const activeSessions = sessions.filter(session => {\n      return (session.lastActivityAt || session.startedAt) > cutoffTime;\n    });\n    \n    await this.saveSessions(activeSessions);\n    return sessions.length - activeSessions.length;\n  }\n}\n\nmodule.exports = new SessionManager();\n